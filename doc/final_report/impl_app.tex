The component of our solution that a user actually sees and interacts with is an Android app. The reason for going mobile is that mobile devices are now the primary gateway to computing and internet for a vast number of users~\cite{statcount}. Android has emerged as the most popular smartphone OS in recent years~\cite{idc_android}, so we decided to build our application for Android.

The application fulfils all the requirements noted down in the Problem and Solution section. The various screens that enable users to accomplish these functions are shown in Fig.~\ref{fig:screens} (not an exhaustive set). Fig.~\ref{fig:screen1} shows the main entry point into the app. This shows an overview of the various IoT devices owned by the user, and whether the data collected by those devices are shared or not. Clicking on any of these entries shows the details corresponding to that device (Fig.~\ref{fig:screen2}). Users can revoke granted permissions by long pressing an entry in the 'Data sharing' section. Fig.~\ref{fig:screen4} shows the screen which lists the pending data requests. Users can accept or deny each request individually, or accept or reject all requests in one go using the button at bottom-right. Users also have an option to automatically accept/reject all future requests from a particular data requester for a particular device.

The app hides the complexities of collecting data from various sources and communications with the remote server. The basic communication scheme between the app and server is shown in Fig.~\ref{fig:app_server_comm}. The communication happens over https, and the app sends authentication details to the server with each request.

Additionally, the app also stores certain metadata, which is collected by the server by coordinating with data sources and requesters, to present a better description of the third-parties to the user, instead of just using the public key identity of third parties. The various entities in the metadata are defined below:

\begin{enumerate}
	\item Device: This entity represents a physical device owned by the user. The associated details like device name, type, data source used to store data etc are stored here.

	\item Device data summary: This entity exists because each device can expose various temporal and/or spatial summaries of the data generated by it. It is the responsibility of each device to define its own summaries and make the data source aware of the different summaries. The data requesters are also made aware of the possible summaries so that they can request a suitable level of summarization.

	\item Data source: This entity exists to identify a data source by a name, so that it becomes familiar to the user.

	\item Data requester: Similar to a data source, this entity stores a name for a data requester.

	\item Trusted agent: Similar to a data source, this entity stores a name for a trusted party.

	\item Data access request/permission: Each access request or granted permission must link together a device data summary (the data for which request is being issued/permission is granted), and a data requester.

	\item Endorsement: This keeps track of the endorsements which each data requester has.
\end{enumerate}

The development of the app took place in 3 stages.
\begin{enumerate}
	\item UI mockups and initial user study: We initially created low fidelity mockups of the app screens. This was done by borrowing app design ideas from Material design principles, as well as Rico~\cite{rico}. We then ran a small scale user study where we showed the mockups to a 3 users, explained the tasks that the interface is supposed to accomplish. We then collected their feedbacks on the strengths and weaknesses of the interface.

	The study showed that the following design choices enhance the experience.

	\begin{itemize}
		\item Overall view of the devices and data is very helpful.
		\item Notifications screen is well done because users can see whether the requester is endorsed and act on the notification from the same screen.
		\item Users also feel more comfortable with IoT devices when a privacy-control mechanism like this app is present.
	\end{itemize}

	We also identified some major areas of concern.

	\begin{itemize}
		\item Users need more control over what data is stored. In particular, they might want to delete data between certain time periods.
		\item Users want to minimize the data shared with third parties, and hence each device should expose various spatial and temporal summarizations. 
		\item Guarantee of anonymity is a must when sharing sensitive data with third parties, especially for analytics purposes.
	\end{itemize}

	\item Implementation: The next phase was to develop the actual app, taking into consideration the feedback that we received in the initial phase. Two of the major concerns identified in the previous phase were addressed during the implementation. Firstly, we introduced Device data summaries to make only the bare essential data available to the data requesters. Second, data requesters cannot link collcted data to data owner by default. This is a property of the protocol that we are following. However, when the user wants the data requester to provide them personalized services based on the data, they can authorize the data requester to get their public key from the app. We started off the implementation with mock data initially and hooked it up with the server later.

	\item Evaluation of the implemented interface: User evaluation at this stage was done at a larger scale using Amazon mechanical turk. Details can be found in the `User Study' section.
\end{enumerate}